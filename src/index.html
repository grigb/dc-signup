<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Join Distributed Creatives</title>
    <meta name="description" content="Join the founding members of Distributed Creatives - the creator-owned network advocating for artist rights and community building.">
    
    <!-- PWA Meta Tags -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="DC Genesis">
    
    <!-- SEO Meta Tags -->
    <meta property="og:title" content="Join Distributed Creatives">
    <meta property="og:description" content="Join the founding members of the creator-owned network advocating for artist rights.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://signup.distributedcreatives.org">
    
    <!-- Security -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://jgnyutkpxapaghderjmj.supabase.co https://cdn.jsdelivr.net; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline';">
    
    <!-- Preconnect to improve performance -->
    <link rel="preconnect" href="https://jgnyutkpxapaghderjmj.supabase.co">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    
    <!-- Supabase CDN -->
    <link rel="stylesheet" href="index.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
</head>
<body>
    <div class="container">
        <!-- Fixed Header with Logo -->
        <div class="logo" onclick="goToHomepage()">
            <img src="./assets/images/distributed-creatives-logo-320px.png?v=2" alt="Distributed Creatives Logo">
            <h1>Distributed Creatives</h1>
            <p>Join Our Community</p>
            <div id="testModeIndicator" style="display: none; background: #f59e0b; color: white; padding: 8px; border-radius: 4px; margin-top: 8px; font-size: 12px; font-weight: 600;">üß™ TEST MODE: Offline Simulation</div>
        </div>

        <div class="connection-status" id="connectionStatus">
            üü° Checking connection...
        </div>
        
        <div id="syncStatus" style="display: none; background: #3b82f6; color: white; padding: 8px; border-radius: 4px; margin-bottom: 16px; text-align: center; font-size: 12px; font-weight: 600;"></div>

        <!-- View Toggle -->
        <div class="view-toggle" id="viewToggle" style="display: none;">
            <button id="formViewBtn" class="active">New Signup</button>
            <button id="offlineViewBtn">View Offline (<span id="offlineCount">0</span>)</button>
        </div>

        <div class="success" id="successMessage"></div>
        <div class="error" id="errorMessage"></div>

        <!-- Scrollable Content Area -->
        <div class="scrollable-content">
            <form id="signupForm">
            <div class="form-group">
                <label for="name">Full Name *</label>
                <input type="text" id="name" name="name" required>
            </div>

            <div class="form-group">
                <label for="email">Email Address *</label>
                <input type="email" id="email" name="email" required>
            </div>

            <div class="form-group creator-type-container">
                <label>Creator Type (optional - helps us build community)</label>
                <div class="simple-creator-input" onclick="openCreatorTypeModal()">
                    <span id="creatorTypeDisplay">Click to select if you're a creator</span>
                    <span id="selectionCount">0 selected</span>
                </div>
                
                <div class="selected-types" id="selectedTypes">
                    <!-- Selected types populated by JavaScript -->
                </div>
            </div>

            <!-- Hidden legacy input to maintain backward-compatibility for older JS functions -->
            <input type="hidden" id="otherInput" value="">

            <div class="form-group">
                <label for="country">Country</label>
                <select id="country" name="country">
                    <option value="">Select your country</option>
                    <option value="United States">United States</option>
                    <option value="Canada">Canada</option>
                    <option value="United Kingdom">United Kingdom</option>
                    <option value="Australia">Australia</option>
                    <option value="Germany">Germany</option>
                    <option value="France">France</option>
                    <option value="Japan">Japan</option>
                    <option value="Brazil">Brazil</option>
                    <option value="India">India</option>
                    <option value="Other">Other</option>
                </select>
            </div>

            <!-- Privacy Controls -->
            <div class="privacy-section">
                <h3>üîí Website Display Preferences</h3>
                
                <div class="privacy-option">
                    <input type="checkbox" id="allowNameDisplay" name="allowNameDisplay">
                    <label for="allowNameDisplay">
                        Display my name on the website
                        <div class="privacy-description">We can show "John Smith" in member lists</div>
                    </label>
                </div>
                
                <div class="privacy-option">
                    <input type="checkbox" id="allowCreatorTypeDisplay" name="allowCreatorTypeDisplay">
                    <label for="allowCreatorTypeDisplay">
                        Display my creator type(s) on the website
                        <div class="privacy-description">We can show "Digital Artist" or your selected creator types</div>
                    </label>
                </div>
                
                <div class="privacy-option">
                    <input type="checkbox" id="allowCommentsDisplay" name="allowCommentsDisplay">
                    <label for="allowCommentsDisplay">
                        Display my comments/bio on the website
                        <div class="privacy-description">We can publish your testimonial or bio if provided</div>
                    </label>
                </div>
                
                <div class="privacy-option">
                    <input type="checkbox" id="includeInGenesisGroup" name="includeInGenesisGroup">
                    <label for="includeInGenesisGroup">
                        Include me in the "Genesis Members" showcase
                        <div class="privacy-description">Feature me as a founding community member</div>
                    </label>
                </div>
            </div>

            <!-- Member Showcase Section -->
            <div class="member-showcase" id="memberShowcase">
                <h4>‚ú® Tell us about yourself (optional)</h4>
                
                <div class="form-group">
                    <label for="memberBio">About You</label>
                    <textarea 
                        id="memberBio" 
                        name="memberBio" 
                        placeholder="Share something about your creative work, background, or what you're working on."
                        maxlength="300"
                    ></textarea>
                    <div class="char-count" id="bioCharCount">0/300 characters</div>
                </div>

                <div class="form-group">
                    <label for="memberQuote">Testimonial or Quote About DC</label>
                    <textarea 
                        id="memberQuote" 
                        name="memberQuote" 
                        placeholder="Share why you're excited about Distributed Creatives, why you joined, or your thoughts on creator rights."
                        maxlength="500"
                    ></textarea>
                    <div class="char-count" id="quoteCharCount">0/500 characters</div>
                    <div style="font-size: 12px; color: #059669; margin-top: 16px; margin-bottom: 8px; font-style: italic;">
                        üí° Your testimonial helps us attract like-minded creators and showcase our community's impact
                    </div>
                </div>
            </div>
            </form>
        </div>

        <!-- Fixed Bottom Button Area -->
        <div class="fixed-bottom">
            <button type="button" class="submit-btn" id="submitBtn" onclick="handleFormSubmit()">
                Review Submission
            </button>
        </div>

        <!-- Confirmation Step -->
        <div id="confirmationStep" style="display: none;">
            <div class="confirmation-container">
                <!-- Fixed Header -->
                <div class="confirmation-header">
                    <h2>üìã Review Your Submission</h2>
                    <p>Please confirm all details are correct before joining</p>
                </div>
                
                <!-- Scrollable Content -->
                <div class="scrollable-content">
                    <div id="confirmationDetails" class="confirmation-details">
                        <!-- Details populated by JavaScript -->
                    </div>
                </div>

                <div class="fixed-bottom">
                    <div style="display: flex; gap: 12px;">
                        <button type="button" class="submit-btn" id="editBtn" style="background: #64748b; flex: 1;" onclick="handleEditDetails()">
                            ‚Üê Edit Details
                        </button>
                        <button type="button" class="submit-btn" id="confirmSubmitBtn" style="flex: 2;">
                            Join the Community
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Offline Submissions Viewer -->
        <div id="offlineViewer" style="display: none;">
            <div class="offline-container">
                <div class="logo" onclick="goToHomepage()">
                    <img src="./assets/images/distributed-creatives-logo-320px.png?v=2" alt="Distributed Creatives Logo">
                    <h2>üì± Offline Submissions</h2>
                    <p>Submissions waiting to sync</p>
                </div>

                <div class="scrollable-content">
                    <div id="offlineSubmissionsList">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>

                <div class="fixed-bottom">
                    <div style="display: flex; gap: 12px;">
                        <button type="button" class="submit-btn" id="backToFormBtn" style="background: #64748b; flex: 1;">
                            ‚Üê Back to Form
                        </button>
                        <button type="button" class="submit-btn" id="syncNowBtn" style="flex: 1;">
                            Sync Now
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Creator Type Modal -->
    <div id="creatorTypeModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <!-- Fixed Header -->
            <div class="modal-header">
                <h3 class="modal-title">Select Your Creator Types (Optional)</h3>
                <button class="modal-close" onclick="closeCreatorTypeModal()">&times;</button>
            </div>
            
            <!-- Scrollable Content -->
            <div class="modal-scrollable-content">
                <div class="creator-type-categories" id="creatorTypeCategories">
                    <!-- Creator type categories populated by JavaScript -->
                </div>
            </div>
            
            <!-- Fixed Bottom Buttons -->
            <div class="modal-fixed-bottom">
                <div style="display: flex; gap: 12px;">
                    <button type="button" class="submit-btn" onclick="closeCreatorTypeModal()" style="background: #64748b; flex: 1;">
                        Cancel
                    </button>
                    <button type="button" class="submit-btn" onclick="saveCreatorTypes()" style="flex: 2;">
                        Save Selection
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        console.log('[SCRIPT START] DC Signup System script is starting...');
        // Configuration - Use environment variables in production
        // Environment variables - replaced by Cloudflare Pages build process
        const SUPABASE_URL = 'https://jgnyutkpxapaghderjmj.supabase.co'
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Impnbnl1dGtweGFwYWdoZGVyam1qIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTEyOTE5MTMsImV4cCI6MjA2Njg2NzkxM30.4GkS72fKX9trYQIfeXMmZJ2iM2menAjYdCHuHb3dOs8'
        
        // Check if API keys are properly configured
        const hasValidApiKey = SUPABASE_ANON_KEY !== '__SUPABASE_' + 'ANON_KEY__' && SUPABASE_ANON_KEY.startsWith('eyJ')
        
        // Initialize Supabase client
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
        
        // Log configuration status and provide guidance
        if (!hasValidApiKey) {
            console.warn('‚ö†Ô∏è API configuration incomplete. Running in offline-only mode.')
            console.warn('üí° To enable online sync:')
            console.warn('   1. Copy config.template.js to config.js')
            console.warn('   2. Add your Supabase API keys to config.js')
            console.warn('   3. OR set window.SUPABASE_ANON_KEY before loading this script')
            console.warn('üìù All form submissions will be saved locally and can sync later')
        } else {
            console.log('‚úÖ API configuration detected. Online sync enabled.')
        }
        
        // Creator Types - loaded from external JSON file
        let creatorTypes = []
        
        // State management
        let isOnline = navigator.onLine
        let selectedCreatorTypes = []
        let currentLevel = []
        let navigationPath = []
        let otherValue = ""
        
        // Test mode - simulate offline behavior
        const urlParams = new URLSearchParams(window.location.search)
        const testOfflineMode = urlParams.get('offline') === 'true'
        if (testOfflineMode) {
            isOnline = false
            console.log('üß™ TEST MODE: Simulating offline behavior')
        }
        
        // DOM elements
        const form = document.getElementById('signupForm')
        const connectionStatus = document.getElementById('connectionStatus')
        const successMessage = document.getElementById('successMessage')
        const errorMessage = document.getElementById('errorMessage')
        const creatorTypeList = document.getElementById('creatorTypeCategories')
        const selectedTypesContainer = document.getElementById('selectedTypes')
        const currentCategoryLabel = document.getElementById('currentCategoryLabel')
        const selectionCount = document.getElementById('selectionCount')
        const creatorTypeNav = document.getElementById('creatorTypeNav')
        const navBack = document.getElementById('navBack')
        const navPath = document.getElementById('navPath')
        const otherInput = document.getElementById('otherInput')
        const otherText = document.getElementById('otherText')
        const memberShowcase = document.getElementById('memberShowcase')
        const memberBio = document.getElementById('memberBio')
        const memberQuote = document.getElementById('memberQuote')
        const bioCharCount = document.getElementById('bioCharCount')
        const quoteCharCount = document.getElementById('quoteCharCount')

        // Load creator types from database with JSON fallback
        async function loadCreatorTypes() {
            // In test offline mode, skip database and use local file
            if (testOfflineMode) {
                console.log('üß™ TEST MODE: Skipping database, loading from local file')
                return loadCreatorTypesFromFile()
            }
            
            try {
                // First try to load from Supabase database
                const { data, error } = await supabase.rpc('get_creator_types_json')
                
                if (error) {
                    console.error('Database error loading creator types:', error)
                    return loadCreatorTypesFromFile()
                }
                
                if (data && data.creatorTypes) {
                    creatorTypes = data.creatorTypes
                    console.log('‚úÖ Creator types loaded from database:', data.version)
                    console.log('Found', creatorTypes.length, 'creator type categories')

                    // Auto-render if modal already open or will open soon
                    loadCreatorTypesIntoModal()
                } else {
                    console.warn('No creator types data received, falling back to file')
                    return loadCreatorTypesFromFile()
                }
            } catch (error) {
                console.error('Failed to load creator types from database:', error)
                return loadCreatorTypesFromFile()
            }
        }

        // Fallback: Load creator types from local JSON file
        async function loadCreatorTypesFromFile() {
            try {
                const response = await fetch('./creator-types.json')
                const data = await response.json()
                creatorTypes = data.creatorTypes
                console.log('üìÑ Creator types loaded from local file:', data.version)
                // Ensure UI updates when loading from file
                loadCreatorTypesIntoModal()
            } catch (error) {
                console.error('Failed to load creator types from file:', error)
                // Final fallback to hardcoded list with hierarchy
                creatorTypes = [
                    {
                        id: 'traditional-arts',
                        label: 'Traditional Arts',
                        description: 'Classic artistic mediums and forms',
                        children: [
                            { id: 'visual-arts', label: 'Visual Arts', description: 'Painting, drawing, sculpture' },
                            { id: 'music', label: 'Music', description: 'Composition, performance, production' },
                            { id: 'writing', label: 'Writing', description: 'Fiction, non-fiction, poetry' },
                            { id: 'photography', label: 'Photography', description: 'Digital and film photography' },
                            { id: 'performance-acting', label: 'Performance/Acting', description: 'Theater, film, live performance' }
                        ]
                    },
                    {
                        id: 'technical-creation',
                        label: 'Technical Creation',
                        description: 'Technology-focused creative work',
                        children: [
                            { id: 'software-development', label: 'Software Development', description: 'Applications, systems, tools' },
                            { id: 'game-development', label: 'Game Development', description: 'Video games, interactive media' },
                            { id: 'web-development', label: 'Web Development', description: 'Websites, web applications' },
                            { id: 'engineering', label: 'Engineering', description: 'Hardware, systems, innovation' },
                            { id: 'data-science', label: 'Data Science', description: 'Analytics, visualization, AI/ML' }
                        ]
                    },
                    {
                        id: 'content-creation',
                        label: 'Content Creation',
                        description: 'Digital content and media production',
                        children: [
                            { id: 'video', label: 'Video', description: 'Film, streaming, video production' },
                            { id: 'podcasting', label: 'Podcasting', description: 'Audio content, broadcasting' },
                            { id: 'blogging', label: 'Blogging', description: 'Written online content' },
                            { id: 'social-media', label: 'Social Media', description: 'Platform-specific content creation' }
                        ]
                    },
                    {
                        id: 'design-fields',
                        label: 'Design Fields',
                        description: 'Visual and functional design work',
                        children: [
                            { id: 'ux-ui-design', label: 'UX/UI Design', description: 'User experience, interface design' },
                            { id: 'graphic-design', label: 'Graphic Design', description: 'Visual communication, branding' },
                            { id: 'industrial-design', label: 'Industrial Design', description: 'Product design, manufacturing' }
                        ]
                    },
                    {
                        id: 'other',
                        label: 'Other',
                        description: 'Creative work not listed above',
                        children: []
                    }
                ]
                console.log('‚ö†Ô∏è Using hardcoded creator types fallback')
            }
        }

        // Force centering with JavaScript as fallback
        function ensureCentering() {
            const container = document.querySelector('.container')
            const body = document.body
            
            // Check if container is properly centered
            const containerRect = container.getBoundingClientRect()
            const bodyRect = body.getBoundingClientRect()
            
            const isHorizontallyCentered = Math.abs(
                containerRect.left - (bodyRect.width - containerRect.width) / 2
            ) < 10
            
            const isVerticallyCentered = Math.abs(
                containerRect.top - (bodyRect.height - containerRect.height) / 2
            ) < 10
            
            if (!isHorizontallyCentered || !isVerticallyCentered) {
                console.log('Container not properly centered, applying JS fallback')
                
                // Apply fixed positioning fallback
                container.style.position = 'fixed'
                container.style.top = '50%'
                container.style.left = '50%'
                container.style.transform = 'translate(-50%, -50%)'
                container.style.margin = '0'
                
                // Ensure body background covers full viewport
                body.style.position = 'fixed'
                body.style.top = '0'
                body.style.left = '0'
                body.style.width = '100%'
                body.style.height = '100%'
                body.style.overflow = 'hidden'
            }
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            // Show test mode indicator if in test mode
            if (testOfflineMode) {
                document.getElementById('testModeIndicator').style.display = 'block'
            }
            
            updateConnectionStatus()
            loadCreatorTypes() // Load creator types first
            setupPrivacyControls()
            setupCharacterCounters()
            registerServiceWorker() // Enable offline functionality
            
            // Auto-sync pending submissions on page load if online
            if (isOnline && !testOfflineMode) {
                setTimeout(() => syncPendingFromLocal(), 2000)
            }
            
            // Listen for connection changes
            window.addEventListener('online', handleOnline)
            window.addEventListener('offline', handleOffline)
            
            // Ensure proper centering after page load
            setTimeout(ensureCentering, 100)
            
            // Re-check centering on window resize
            window.addEventListener('resize', ensureCentering)
        })

        // Service Worker Registration for PWA/Offline functionality
        async function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                try {
                    const registration = await navigator.serviceWorker.register('./sw.js')
                    console.log('Service Worker registered successfully:', registration.scope)
                    
                    // Listen for service worker updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // New content available, refresh page
                                console.log('New content available, refreshing...')
                                window.location.reload()
                            }
                        })
                    })
                    
                    // Listen for messages from service worker
                    navigator.serviceWorker.addEventListener('message', (event) => {
                        if (event.data.type === 'SYNC_PENDING_SUBMISSIONS') {
                            console.log('Syncing pending submissions...')
                            syncPendingFromLocal()
                        }
                    })
                    
                } catch (error) {
                    console.log('Service Worker registration failed:', error)
                }
            } else {
                console.log('Service Workers not supported')
            }
        }

        // Creator Type Selector Logic
        function renderCreatorTypes() {
            // Add null check for creatorTypeList
            if (!creatorTypeList) {
                console.warn('creatorTypeList element not found')
                return
            }
            
            if (!creatorTypes || creatorTypes.length === 0) {
                creatorTypeList.innerHTML = '<div style="padding: 16px; text-align: center; color: #64748b;">Loading creator types...</div>'
                return
            }
            
            creatorTypeList.innerHTML = ''
            
            currentLevel.forEach(option => {
                const optionDiv = document.createElement('div')
                optionDiv.className = 'creator-type-option'
                
                if (selectedCreatorTypes.includes(option.id)) {
                    optionDiv.classList.add('selected')
                }
                
                optionDiv.innerHTML = `
                    <div class="option-content">
                        <span>${option.label}</span>
                    </div>
                    ${option.children ? '<span class="option-icon chevron-icon">‚Ä∫</span>' : 
                      selectedCreatorTypes.includes(option.id) ? '<span class="option-icon check-icon">‚úì</span>' : ''}
                `
                
                optionDiv.addEventListener('click', () => handleCreatorTypeClick(option))
                creatorTypeList.appendChild(optionDiv)
            })
            
            updateCreatorTypeHeader()
            updateNavigationVisibility()
        }

        function handleCreatorTypeClick(option) {
            if (option.children) {
                // Navigate to children
                navigationPath.push(option)
                currentLevel = option.children
                renderCreatorTypes()
            } else if (option.id === 'other') {
                // Toggle other input
                const isVisible = otherInput.classList.contains('visible')
                if (isVisible) {
                    otherInput.classList.remove('visible')
                    if (otherValue) {
                        removeCreatorType(`other:${otherValue}`)
                    }
                } else {
                    otherInput.classList.add('visible')
                    if (otherText) {
                        otherText.focus()
                    }
                }
            } else {
                // Toggle selection
                if (selectedCreatorTypes.includes(option.id)) {
                    removeCreatorType(option.id)
                } else {
                    selectedCreatorTypes.push(option.id)
                }
                renderCreatorTypes()
                updateSelectedTypes()
            }
        }

        function removeCreatorType(typeId) {
            selectedCreatorTypes = selectedCreatorTypes.filter(id => id !== typeId)
            renderCreatorTypes()
            updateSelectedTypes()
        }

        function updateCreatorTypeHeader() {
            const count = selectedCreatorTypes.length + (otherValue ? 1 : 0)
            
            // Add null check for selectionCount
            if (selectionCount) {
                selectionCount.textContent = `${count} selected`
            }
            
            // Add null check for currentCategoryLabel
            if (currentCategoryLabel) {
                if (navigationPath.length === 0) {
                    currentCategoryLabel.textContent = 'Choose your creator types'
                } else {
                    currentCategoryLabel.textContent = navigationPath[navigationPath.length - 1].label
                }
            }
        }

        function updateNavigationVisibility() {
            // Add null checks for navigation elements
            if (!creatorTypeNav || !navPath) {
                return
            }
            
            if (navigationPath.length > 0) {
                creatorTypeNav.classList.add('visible')
                navPath.textContent = navigationPath.map(item => item.label).join(' ‚Ä∫ ')
            } else {
                creatorTypeNav.classList.remove('visible')
            }
        }

        function updateSelectedTypes() {
            // Add null check for selectedTypesContainer
            if (!selectedTypesContainer) {
                return
            }
            
            selectedTypesContainer.innerHTML = ''
            
            selectedCreatorTypes.forEach(typeId => {
                const option = findOptionById(typeId)
                if (option) {
                    const tag = document.createElement('div')
                    tag.className = 'selected-type-tag'
                    tag.innerHTML = `
                        ${option.label}
                        <button type="button" class="remove-type" onclick="removeCreatorType('${typeId}')">√ó</button>
                    `
                    selectedTypesContainer.appendChild(tag)
                }
            })
            
            if (otherValue) {
                const tag = document.createElement('div')
                tag.className = 'selected-type-tag'
                tag.innerHTML = `
                    Other: ${otherValue}
                    <button type="button" class="remove-type" onclick="removeOtherType()">√ó</button>
                `
                selectedTypesContainer.appendChild(tag)
            }
        }

        function findOptionById(id) {
            function search(options) {
                for (const option of options) {
                    if (option.id === id) return option
                    if (option.children) {
                        const found = search(option.children)
                        if (found) return found
                    }
                }
                return null
            }
            return search(creatorTypes)
        }

        // Navigation handlers - add null check
        if (navBack) {
            navBack.addEventListener('click', () => {
                if (navigationPath.length > 0) {
                    navigationPath.pop()
                    if (navigationPath.length === 0) {
                        currentLevel = creatorTypes
                    } else {
                        currentLevel = navigationPath[navigationPath.length - 1].children
                    }
                    renderCreatorTypes()
                }
            })
        }

        // Other input handler - add null check
        if (otherText) {
            otherText.addEventListener('input', (e) => {
                otherValue = e.target.value.trim()
                updateCreatorTypeHeader()
                updateSelectedTypes()
            })
        }

        function removeOtherType() {
            otherValue = ""
            if (otherText) {
                otherText.value = ""
            }
            otherInput.classList.remove('visible')
            updateCreatorTypeHeader()
            updateSelectedTypes()
        }

        // Privacy Controls
        function setupPrivacyControls() {
            const privacyCheckboxes = ['allowNameDisplay', 'allowCreatorTypeDisplay', 'allowCommentsDisplay', 'includeInGenesisGroup']
            
            privacyCheckboxes.forEach(id => {
                const checkbox = document.getElementById(id)
                checkbox.addEventListener('change', updateMemberShowcase)
            })
        }

        function updateMemberShowcase() {
            const anyDisplayAllowed = document.getElementById('allowNameDisplay').checked ||
                                    document.getElementById('allowCreatorTypeDisplay').checked ||
                                    document.getElementById('allowCommentsDisplay').checked ||
                                    document.getElementById('includeInGenesisGroup').checked
            
            if (anyDisplayAllowed) {
                memberShowcase.classList.add('visible')
            } else {
                memberShowcase.classList.remove('visible')
            }
        }

        // Character counters
        function setupCharacterCounters() {
            // Bio character counter
            if (memberBio && bioCharCount) {
                memberBio.addEventListener('input', (e) => {
                    const count = e.target.value.length
                    bioCharCount.textContent = `${count}/300 characters`
                    
                    if (count > 250) {
                        bioCharCount.style.color = '#f59e0b'
                    } else {
                        bioCharCount.style.color = '#059669'
                    }
                })
            }

            // Quote character counter
            if (memberQuote && quoteCharCount) {
                memberQuote.addEventListener('input', (e) => {
                    const count = e.target.value.length
                    quoteCharCount.textContent = `${count}/500 characters`
                    
                    if (count > 450) {
                        quoteCharCount.style.color = '#f59e0b'
                    } else {
                        quoteCharCount.style.color = '#059669'
                    }
                })
            }
        }

        // Connection handlers
        function handleOnline() {
            isOnline = true
            updateConnectionStatus()
            // Auto-sync pending submissions when coming back online
            setTimeout(() => {
                if (!testOfflineMode) {
                    syncPendingFromLocal()
                }
            }, 1000)
        }

        function handleOffline() {
            isOnline = false
            updateConnectionStatus()
        }

        function updateConnectionStatus() {
            if (isOnline) {
                // Hide status when online - no need to show
                connectionStatus.style.display = 'none'
            } else {
                // Show offline warning
                connectionStatus.innerHTML = 'üî¥ Offline - Saves locally only'
                connectionStatus.className = 'connection-status offline'
                connectionStatus.style.display = 'block'
            }
        }

        // Global variable to store current submission data
        let currentSubmission = null
        
        // Track if user has been warned about creator types
        let creatorTypeWarningShown = false

        // Form submission handler - now shows confirmation step
        form.addEventListener('submit', async function(e) {
            e.preventDefault()
            
            const formData = new FormData(form)
            const name = formData.get('name').trim()
            const email = formData.get('email').trim()
            const country = formData.get('country')
            const bio = memberBio.value.trim()
            const quote = memberQuote.value.trim()
            
            // Validate
            if (!name || !email) {
                showError('Please fill in all required fields.')
                return
            }
            
            const totalTypes = selectedCreatorTypes.length + (otherValue ? 1 : 0)
            if (totalTypes === 0) {
                if (!creatorTypeWarningShown) {
                    // First time - show gentle suggestion
                    creatorTypeWarningShown = true
                    highlightCreatorTypeSection()
                    showError('üí° While not required, selecting your creator type(s) helps us build a stronger community. You can skip this and submit again, or choose your types above.')
                    return
                } else {
                    // Second time - allow submission but show a note
                    console.log('User chose to submit without creator types - allowing submission')
                }
            }

            // Check for duplicate email
            if (await isDuplicateEmail(email)) {
                showError('This email has already been registered.')
                return
            }
            
            // Prepare creator types array
            const creatorTypesArray = [...selectedCreatorTypes]
            if (otherValue) {
                creatorTypesArray.push(`other:${otherValue}`)
            }
            
            // Create submission object
            currentSubmission = {
                id: generateId(),
                name: name,
                email: email,
                creator_types: creatorTypesArray,
                country: country || null,
                member_bio: bio || null,
                member_quote: quote || null,
                allow_name_display: document.getElementById('allowNameDisplay').checked,
                allow_creator_type_display: document.getElementById('allowCreatorTypeDisplay').checked,
                allow_comments_display: document.getElementById('allowCommentsDisplay').checked,
                include_in_genesis_group: document.getElementById('includeInGenesisGroup').checked,
                device_id: getDeviceId(),
                referral_source: 'conference',
                timestamp: new Date().toISOString(),
                sync_status: 'pending',
                attempts: 0
            }
            
            // Show confirmation step
            showConfirmationStep(currentSubmission)
        })

        // Actual submission function called after confirmation
        async function submitConfirmedData(submission) {
            console.log('[TRACE] submitConfirmedData called with:', submission)
            console.trace('Call stack for submitConfirmedData:')
            // Always save locally first
            saveToLocal(submission)
            // Try to save to database if online
            if (isOnline) {
                const success = await saveToDatabase(submission)
                if (success) {
                    submission.sync_status = 'synced'
                    updateLocalSubmission(submission)
                    showSuccess('Registration successful! Please check your email to verify your address and complete your membership.')
                } else {
                    showSuccess('Saved locally. Will sync when connection improves.')
                }
            } else {
                // Mark offline submissions with 'offline' status for proper sync handling
                submission.sync_status = 'offline'
                updateLocalSubmission(submission)
                showSuccess('Saved locally. Will sync when online.')
            }
            console.log('[TRACE] About to reset form and call showFormStep')
            currentSubmission = null
            // Robustly hide confirmation step
            const confirmationStep = document.getElementById('confirmationStep')
            if (confirmationStep) {
                confirmationStep.style.display = 'none'
                confirmationStep.style.visibility = 'hidden'
                confirmationStep.style.zIndex = '-1'
                confirmationStep.classList.remove('visible')
            }
            // Robustly show form and parent scrollable content
            const formElement = document.getElementById('signupForm')
            if (formElement) {
                formElement.style.display = 'block'
                formElement.style.visibility = 'visible'
                const scrollableContent = formElement.parentElement
                if (scrollableContent && scrollableContent.classList.contains('scrollable-content')) {
                    scrollableContent.style.display = 'block'
                    scrollableContent.style.visibility = 'visible'
                }
            }
            // Show the submit button - find the one with submitBtn
            const allFixedBottoms = document.querySelectorAll('.fixed-bottom')
            allFixedBottoms.forEach(fb => {
                if (fb.querySelector('#submitBtn')) {
                    fb.style.display = 'block'
                }
            })
            // Hide offline viewer just in case
            const offlineViewer = document.getElementById('offlineViewer')
            if (offlineViewer) {
                offlineViewer.style.display = 'none'
                offlineViewer.style.visibility = 'hidden'
                offlineViewer.style.zIndex = '-1'
            }
            // Hide view toggle
            const viewToggle = document.getElementById('viewToggle')
            if (viewToggle) viewToggle.style.display = 'none'
            // Show connection status
            const connectionStatus = document.getElementById('connectionStatus')
            if (connectionStatus) connectionStatus.style.display = 'block'
            updateViewToggle()
            form.reset()
            resetForm()
            console.log('[TRACE] Form reset complete')
        }

        function resetForm() {
            console.log('[TRACE] resetForm called')
            selectedCreatorTypes = []
            otherValue = ""
            navigationPath = []
            currentLevel = creatorTypes
            if (otherInput) otherInput.classList.remove('visible')
            if (memberShowcase) memberShowcase.classList.remove('visible')
            console.log('[TRACE] About to call updateSelectedTypes')
            // Don't call renderCreatorTypes() here - it renders into the modal which isn't visible
            updateSelectedTypes()
            if (bioCharCount) bioCharCount.textContent = '0/300 characters'
            if (quoteCharCount) quoteCharCount.textContent = '0/500 characters'
            console.log('[TRACE] resetForm complete')
        }

        // Database operations
        async function saveToDatabase(submission, forceSave = false) {
            // In test offline mode, simulate database failure UNLESS we're force saving during sync
            if (testOfflineMode && !forceSave) {
                console.log('üß™ TEST MODE: Simulating database connection failure')
                return false
            }
            
            // Check if API is properly configured
            if (!hasValidApiKey) {
                console.log('üíæ Skipping database save - API not configured. Saved locally only.')
                return false
            }
            
            try {
                // First check if email already exists in database
                const { data: existingMembers, error: checkError } = await supabase
                    .from('members')
                    .select('email')
                    .eq('email', submission.email)
                
                if (existingMembers && existingMembers.length > 0) {
                    console.log(`Email ${submission.email} already exists in database, marking as synced`)
                    return true // Consider it synced since it's already there
                }
                
                // Generate verification token - the database function will handle sending the email
                const verificationToken = crypto.randomUUID().replace(/-/g, '') + crypto.randomUUID().replace(/-/g, '')
                
                const { data, error } = await supabase
                    .from('members')
                    .insert([{
                        name: submission.name,
                        email: submission.email,
                        creator_types: submission.creator_types,
                        country: submission.country,
                        member_bio: submission.member_bio,
                        allow_name_display: submission.allow_name_display,
                        allow_creator_type_display: submission.allow_creator_type_display,
                        allow_comments_display: submission.allow_comments_display,
                        include_in_genesis_group: submission.include_in_genesis_group,
                        device_id: submission.device_id,
                        referral_source: submission.referral_source,
                        sync_source: 'conference',
                        email_verified: false,
                        verification_token: verificationToken,
                        verification_sent_at: new Date().toISOString()
                    }])
                
                if (error) {
                    console.error('Database save error:', error)
                    // Check for specific error types
                    if (error.code === '23505' || error.message?.includes('duplicate')) {
                        console.log(`Email ${submission.email} already exists (duplicate key error), marking as synced`)
                        return true // Consider it synced since it's a duplicate
                    }
                    return false
                }
                
                console.log('Saved to database:', data)
                return true
            } catch (error) {
                console.error('Database connection error:', error)
                return false
            }
        }

        async function isDuplicateEmail(email) {
            // Check local storage first
            const localSubmissions = getLocalSubmissions()
            const localDupe = localSubmissions.some(sub => sub.email === email)
            
            if (localDupe) return true
            
            // In test offline mode, skip database check
            if (testOfflineMode) {
                console.log('üß™ TEST MODE: Skipping database duplicate check')
                return false
            }
            
            // Check database if online
            if (isOnline) {
                try {
                    const { data, error } = await supabase
                        .from('members')
                        .select('email')
                        .eq('email', email)
                        .limit(1)
                    
                    return data && data.length > 0
                } catch (error) {
                    console.error('Duplicate check error:', error)
                    return false
                }
            }
            
            return false
        }

        // Local storage operations
        function saveToLocal(submission) {
            const submissions = getLocalSubmissions()
            submissions.push(submission)
            localStorage.setItem('dcSignups', JSON.stringify(submissions))
        }

        function getLocalSubmissions() {
            return JSON.parse(localStorage.getItem('dcSignups') || '[]')
        }

        function updateLocalSubmission(updatedSubmission) {
            const submissions = getLocalSubmissions()
            
            // Remove ALL entries with the same email to prevent duplicates
            const filteredSubmissions = submissions.filter(sub => sub.email !== updatedSubmission.email)
            console.log(`[DEBUG] updateLocalSubmission: Removed ${submissions.length - filteredSubmissions.length} entries for ${updatedSubmission.email}`)
            
            // Add the updated submission
            filteredSubmissions.push(updatedSubmission)
            localStorage.setItem('dcSignups', JSON.stringify(filteredSubmissions))
            
            console.log(`[DEBUG] updateLocalSubmission: Updated ${updatedSubmission.email} status to ${updatedSubmission.sync_status}`)
            
            // Verify the update was saved
            const verifySubmissions = JSON.parse(localStorage.getItem('dcSignups') || '[]')
            const matchingEntries = verifySubmissions.filter(sub => sub.email === updatedSubmission.email)
            console.log(`[DEBUG] updateLocalSubmission: Verification - ${updatedSubmission.email} now has ${matchingEntries.length} entry(ies) with status ${matchingEntries[0]?.sync_status}`)
            
            return true
        }

        // Sync pending submissions when coming back online
        async function syncPendingFromLocal() {
            if (!isOnline) return
            
            const submissions = getLocalSubmissions()
            let pendingSubmissions = submissions.filter(sub => sub.sync_status === 'pending' || sub.sync_status === 'offline')
            
            // Deduplicate submissions by email and timestamp
            const seen = new Set()
            pendingSubmissions = pendingSubmissions.filter(sub => {
                const key = `${sub.email}-${sub.created_at}`
                if (seen.has(key)) {
                    console.log(`Skipping duplicate submission for ${sub.email}`)
                    // Mark duplicate as failed to remove from pending count
                    sub.sync_status = 'duplicate'
                    updateLocalSubmission(sub)
                    return false
                }
                seen.add(key)
                return true
            })
            
            if (pendingSubmissions.length === 0) {
                console.log('No pending submissions to sync')
                return
            }
            
            console.log(`Syncing ${pendingSubmissions.length} pending submissions...`)
            console.log('[DEBUG] Pending submissions structure:', pendingSubmissions.map(s => ({email: s.email, id: s.id, sync_status: s.sync_status})))
            showSyncStatus(`üîÑ Syncing ${pendingSubmissions.length} offline submissions...`)
            
            let syncedCount = 0
            let failedCount = 0
            
            for (const submission of pendingSubmissions) {
                // Skip if we've already tried too many times
                if (submission.attempts >= 3) {
                    submission.sync_status = 'failed'
                    updateLocalSubmission(submission)
                    console.log(`Marking submission for ${submission.email} as permanently failed after ${submission.attempts} attempts`)
                    continue
                }
                
                const success = await saveToDatabase(submission, true)
                if (success) {
                    submission.sync_status = 'synced'
                    updateLocalSubmission(submission)
                    syncedCount++
                    console.log(`Synced submission for ${submission.email}`)
                } else {
                    submission.attempts = (submission.attempts || 0) + 1
                    // Mark as failed after 3 attempts
                    if (submission.attempts >= 3) {
                        submission.sync_status = 'failed'
                        console.log(`Marking submission for ${submission.email} as permanently failed after ${submission.attempts} attempts`)
                    }
                    updateLocalSubmission(submission)
                    failedCount++
                    console.log(`Failed to sync submission for ${submission.email}, attempt ${submission.attempts}`)
                }
            }
            
            if (syncedCount > 0) {
                showSyncStatus(`‚úÖ Synced ${syncedCount} submissions successfully!`, 'success')
                setTimeout(() => hideSyncStatus(), 3000)
            }
            
            if (failedCount > 0) {
                showSyncStatus(`‚ö†Ô∏è ${failedCount} submissions failed to sync`, 'warning')
                setTimeout(() => hideSyncStatus(), 5000)
            }
            
            // Update the offline count and list after sync
            updateViewToggle()
            populateOfflineSubmissions()
        }
        
        // Migration function to convert old 'pending' submissions to 'offline' if they were from test mode
        function migratePendingToOffline() {
            const submissions = getLocalSubmissions()
            let updated = false
            
            submissions.forEach(submission => {
                // Convert old pending submissions that are likely from offline test mode
                if (submission.sync_status === 'pending' && !submission.attempts) {
                    submission.sync_status = 'offline'
                    submission.attempts = 0
                    updated = true
                    console.log(`Migrating submission ${submission.email} from 'pending' to 'offline'`)
                }
            })
            
            if (updated) {
                localStorage.setItem('dcSignups', JSON.stringify(submissions))
                console.log('Migration completed: converted pending submissions to offline status')
                updateViewToggle()
            }
        }
        
        function showSyncStatus(message, type = 'info') {
            const syncStatus = document.getElementById('syncStatus')
            syncStatus.textContent = message
            syncStatus.style.display = 'block'
            
            // Set color based on type
            switch(type) {
                case 'success':
                    syncStatus.style.background = '#10b981'
                    break
                case 'warning':
                    syncStatus.style.background = '#f59e0b'
                    break
                case 'error':
                    syncStatus.style.background = '#ef4444'
                    break
                default:
                    syncStatus.style.background = '#3b82f6'
            }
        }
        
        function hideSyncStatus() {
            document.getElementById('syncStatus').style.display = 'none'
        }

        // UI helpers
        function showSuccess(message) {
            hideMessages()
            successMessage.textContent = message
            successMessage.style.display = 'block'
            setTimeout(() => successMessage.style.display = 'none', 5000)
        }

        function showError(message) {
            hideMessages()
            errorMessage.textContent = message
            errorMessage.style.display = 'block'
            setTimeout(() => errorMessage.style.display = 'none', 5000)
        }

        function highlightCreatorTypeSection() {
            const creatorTypeSection = document.querySelector('.creator-type-container')
            if (creatorTypeSection) {
                // Add highlight styling
                creatorTypeSection.style.boxShadow = '0 0 0 3px rgba(102, 126, 234, 0.3)'
                creatorTypeSection.style.borderRadius = '8px'
                creatorTypeSection.style.transition = 'box-shadow 0.3s ease'
                
                // Scroll to the section
                creatorTypeSection.scrollIntoView({ behavior: 'smooth', block: 'center' })
                
                // Remove highlight after a few seconds
                setTimeout(() => {
                    creatorTypeSection.style.boxShadow = ''
                }, 5000)
            }
        }

        function hideMessages() {
            successMessage.style.display = 'none'
            errorMessage.style.display = 'none'
        }

        // Utility functions
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2)
        }

        function getDeviceId() {
            let deviceId = localStorage.getItem('dcDeviceId')
            if (!deviceId) {
                deviceId = 'device-' + generateId()
                localStorage.setItem('dcDeviceId', deviceId)
            }
            return deviceId
        }

        // Step Navigation Functions
        function showFormStep() {
            console.log('[TRACE] showFormStep called')
            // More aggressive hiding of confirmation step
            const confirmationStep = document.getElementById('confirmationStep')
            if (confirmationStep) {
                confirmationStep.style.display = 'none'
                confirmationStep.style.visibility = 'hidden'
                confirmationStep.style.zIndex = '-1'
                confirmationStep.classList.remove('visible')
                console.log('[TRACE] Confirmation step hidden')
            }
            
            // Hide offline viewer as well
            const offlineViewer = document.getElementById('offlineViewer')
            if (offlineViewer) {
                offlineViewer.style.display = 'none'
                offlineViewer.style.visibility = 'hidden'
                offlineViewer.style.zIndex = '-1'
            }
            
            // Show the form and its parent scrollable content
            const formElement = document.getElementById('signupForm')
            if (formElement) {
                formElement.style.display = 'block'
                formElement.style.visibility = 'visible'
                // Get the parent scrollable-content that contains the form
                const scrollableContent = formElement.parentElement
                if (scrollableContent && scrollableContent.classList.contains('scrollable-content')) {
                    scrollableContent.style.display = 'block'
                    scrollableContent.style.visibility = 'visible'
                    console.log('[TRACE] Form and scrollable content shown')
                }
            }
            
            // Show the submit button - find the one with submitBtn
            const allFixedBottoms = document.querySelectorAll('.fixed-bottom')
            allFixedBottoms.forEach(fb => {
                if (fb.querySelector('#submitBtn')) {
                    fb.style.display = 'block'
                }
            })
            
            // Show other UI elements that should be visible with the form
            const viewToggle = document.getElementById('viewToggle')
            if (viewToggle) viewToggle.style.display = 'none'
            
            const connectionStatus = document.getElementById('connectionStatus')
            if (connectionStatus) connectionStatus.style.display = 'block'
            
            updateViewToggle()
        }

        function showConfirmationStep(submission) {
            // Hide the entire form section including the submit button
            const formElement = document.getElementById('signupForm')
            if (formElement) {
                formElement.style.display = 'none'
                // Get the parent scrollable-content that contains the form
                const scrollableContent = formElement.parentElement
                if (scrollableContent && scrollableContent.classList.contains('scrollable-content')) {
                    scrollableContent.style.display = 'none'
                }
            }
            
            // Hide the submit button - find the one with submitBtn
            const allFixedBottoms = document.querySelectorAll('.fixed-bottom')
            allFixedBottoms.forEach(fb => {
                if (fb.querySelector('#submitBtn')) {
                    fb.style.display = 'none'
                }
            })
            
            // Hide other form-related UI elements
            const connectionStatus = document.getElementById('connectionStatus')
            if (connectionStatus) connectionStatus.style.display = 'none'
            
            // Show confirmation step with proper visibility and z-index
            const confirmationStep = document.getElementById('confirmationStep')
            if (confirmationStep) {
                confirmationStep.style.display = 'flex'
                confirmationStep.style.visibility = 'visible'
                confirmationStep.style.zIndex = '100'
            }
            
            // Make sure offline viewer is hidden
            const offlineViewer = document.getElementById('offlineViewer')
            if (offlineViewer) {
                offlineViewer.style.display = 'none'
                offlineViewer.style.visibility = 'hidden'
                offlineViewer.style.zIndex = '-1'
            }
            
            hideMessages()
            
            // Populate confirmation details
            populateConfirmationDetails(submission)
        }

        function restoreFormData(submission) {
            // Restore basic form fields
            document.getElementById('name').value = submission.name || ''
            document.getElementById('email').value = submission.email || ''
            document.getElementById('country').value = submission.country || ''
            
            // Restore creator types
            selectedCreatorTypes = submission.creator_types.filter(type => !type.startsWith('other:'))
            const otherTypes = submission.creator_types.filter(type => type.startsWith('other:'))
            if (otherTypes.length > 0) {
                otherValue = otherTypes[0].replace('other:', '')
                const otherTextElement = document.getElementById('otherText')
                if (otherTextElement) {
                    otherTextElement.value = otherValue
                }
                const otherInputElement = document.getElementById('otherInput')
                if (otherInputElement) {
                    otherInputElement.classList.add('visible')
                }
            }
            
            // Restore bio and quote
            if (submission.member_bio) {
                const memberBioElement = document.getElementById('memberBio')
                const bioCharCountElement = document.getElementById('bioCharCount')
                if (memberBioElement) {
                    memberBioElement.value = submission.member_bio
                }
                if (bioCharCountElement) {
                    bioCharCountElement.textContent = `${submission.member_bio.length}/300 characters`
                }
            }
            if (submission.member_quote) {
                const memberQuoteElement = document.getElementById('memberQuote')
                const quoteCharCountElement = document.getElementById('quoteCharCount')
                if (memberQuoteElement) {
                    memberQuoteElement.value = submission.member_quote
                }
                if (quoteCharCountElement) {
                    quoteCharCountElement.textContent = `${submission.member_quote.length}/500 characters`
                }
            }
            
            // Restore privacy settings
            const allowNameElement = document.getElementById('allowNameDisplay')
            const allowCreatorTypeElement = document.getElementById('allowCreatorTypeDisplay')
            const allowCommentsElement = document.getElementById('allowCommentsDisplay')
            const includeGenesisElement = document.getElementById('includeInGenesisGroup')
            
            if (allowNameElement) allowNameElement.checked = submission.allow_name_display || false
            if (allowCreatorTypeElement) allowCreatorTypeElement.checked = submission.allow_creator_type_display || false
            if (allowCommentsElement) allowCommentsElement.checked = submission.allow_comments_display || false
            if (includeGenesisElement) includeGenesisElement.checked = submission.include_in_genesis_group || false
            
            // Update UI elements
            renderCreatorTypes()
            updateSelectedTypes()
            updatePrivacyControls()
        }

        function showOfflineViewer() {
            document.getElementById('signupForm').style.display = 'none'
            document.querySelector('.fixed-bottom').style.display = 'none'
            document.getElementById('confirmationStep').style.display = 'none'
            document.getElementById('offlineViewer').style.display = 'flex'
            hideMessages()
            
            // Populate offline submissions
            populateOfflineSubmissions()
            updateViewToggle()
        }

        function populateConfirmationDetails(submission) {
            const container = document.getElementById('confirmationDetails')
            
            // Format creator types for display
            const creatorTypesDisplay = submission.creator_types.map(type => {
                if (type.startsWith('other:')) {
                    return type.replace('other:', 'Other: ')
                }
                return type
            }).map(type => `<span class="creator-type-chip">${type}</span>`).join('')

            container.innerHTML = `
                <div class="confirmation-item">
                    <span class="confirmation-label">Name:</span>
                    <span class="confirmation-value">${submission.name}</span>
                </div>
                <div class="confirmation-item">
                    <span class="confirmation-label">Email:</span>
                    <span class="confirmation-value">${submission.email}</span>
                </div>
                <div class="confirmation-item">
                    <span class="confirmation-label">Creator Types:</span>
                    <div class="confirmation-value">
                        <div class="creator-types-list">${creatorTypesDisplay}</div>
                    </div>
                </div>
                <div class="confirmation-item">
                    <span class="confirmation-label">Country:</span>
                    <span class="confirmation-value">${submission.country || 'Not specified'}</span>
                </div>
                ${submission.member_bio ? `
                <div class="confirmation-item">
                    <span class="confirmation-label">Bio:</span>
                    <span class="confirmation-value">${submission.member_bio}</span>
                </div>
                ` : ''}
                ${submission.member_quote ? `
                <div class="confirmation-item">
                    <span class="confirmation-label">Testimonial:</span>
                    <span class="confirmation-value">"${submission.member_quote}"</span>
                </div>
                ` : ''}
                <div class="confirmation-item">
                    <span class="confirmation-label">Genesis Group:</span>
                    <span class="confirmation-value">${submission.include_in_genesis_group ? 'Yes' : 'No'}</span>
                </div>
                <div class="confirmation-item">
                    <span class="confirmation-label">Display Name:</span>
                    <span class="confirmation-value">${submission.allow_name_display ? 'Yes' : 'No'}</span>
                </div>
                <div class="confirmation-item">
                    <span class="confirmation-label">Display Creator Types:</span>
                    <span class="confirmation-value">${submission.allow_creator_type_display ? 'Yes' : 'No'}</span>
                </div>
                <div class="confirmation-item">
                    <span class="confirmation-label">Display Comments:</span>
                    <span class="confirmation-value">${submission.allow_comments_display ? 'Yes' : 'No'}</span>
                </div>
            `
        }

        function populateOfflineSubmissions() {
            const container = document.getElementById('offlineSubmissionsList')
            // Only show submissions that are NOT synced (pending, offline, or failed)
            const submissions = getLocalSubmissions().filter(sub => 
                sub.sync_status === 'pending' || 
                sub.sync_status === 'offline' || 
                sub.sync_status === 'failed'
            )
            console.log(`[DEBUG] populateOfflineSubmissions: Found ${submissions.length} unsynced submissions`)
            
            if (submissions.length === 0) {
                container.innerHTML = '<div class="no-offline-submissions">No offline submissions waiting to sync</div>'
                return
            }

            container.innerHTML = submissions.map(sub => `
                <div class="offline-submission" data-id="${sub.id}">
                    <div class="offline-submission-header">
                        <span class="offline-submission-name">${sub.name}</span>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <span class="offline-submission-time">${new Date(sub.timestamp).toLocaleString()}</span>
                            <button class="btn btn-edit" onclick="editOfflineSubmission('${sub.id}')" style="padding: 4px 8px; font-size: 10px;">Edit</button>
                            <button class="btn btn-delete" onclick="deleteOfflineSubmission('${sub.id}')" style="padding: 4px 8px; font-size: 10px;">Delete</button>
                        </div>
                    </div>
                    <div class="offline-submission-details">
                        ${sub.email} ‚Ä¢ ${sub.creator_types.length} creator type(s)
                        ${sub.country ? ` ‚Ä¢ ${sub.country}` : ''}
                        ${sub.member_bio ? `<br><strong>Bio:</strong> ${sub.member_bio.substring(0, 80)}${sub.member_bio.length > 80 ? '...' : ''}` : ''}
                        ${sub.member_quote ? `<br><strong>Testimonial:</strong> "${sub.member_quote.substring(0, 80)}${sub.member_quote.length > 80 ? '...' : ''}"` : ''}
                    </div>
                </div>
            `).join('')
        }

        function updateViewToggle() {
            // Only count submissions that are NOT synced (pending, offline, or failed)
            const allSubmissions = getLocalSubmissions()
            console.log(`[DEBUG] updateViewToggle: All submissions status:`, allSubmissions.map(s => `${s.email}:${s.sync_status}`))
            const offlineSubmissions = allSubmissions.filter(sub => 
                sub.sync_status === 'pending' || 
                sub.sync_status === 'offline' || 
                sub.sync_status === 'failed'
            )
            console.log(`[DEBUG] updateViewToggle: Found ${offlineSubmissions.length} unsynced submissions:`, offlineSubmissions.map(s => `${s.email}:${s.sync_status}`))
            document.getElementById('offlineCount').textContent = offlineSubmissions.length
            
            // Show view toggle if there are offline submissions
            if (offlineSubmissions.length > 0) {
                document.getElementById('viewToggle').style.display = 'block'
            } else {
                document.getElementById('viewToggle').style.display = 'none'
            }
        }

        // Offline submission management functions
        function editOfflineSubmission(submissionId) {
            const submissions = getLocalSubmissions()
            const submission = submissions.find(sub => sub.id === submissionId)
            
            if (!submission) {
                showError('Submission not found')
                return
            }

            // Populate form with submission data
            document.getElementById('name').value = submission.name
            document.getElementById('email').value = submission.email
            
            // Set country
            const countrySelect = document.getElementById('country')
            if (submission.country) {
                countrySelect.value = submission.country
            }

            // Set creator types
            selectedCreatorTypes = submission.creator_types.filter(type => !type.startsWith('other:'))
            const otherTypes = submission.creator_types.filter(type => type.startsWith('other:'))
            if (otherTypes.length > 0) {
                otherValue = otherTypes[0].replace('other:', '')
                document.getElementById('otherText').value = otherValue
                otherInput.classList.add('visible')
            }

            // Set bio and quote
            if (submission.member_bio && memberBio && bioCharCount) {
                memberBio.value = submission.member_bio
                bioCharCount.textContent = `${submission.member_bio.length}/300 characters`
            }
            if (submission.member_quote && memberQuote && quoteCharCount) {
                memberQuote.value = submission.member_quote
                quoteCharCount.textContent = `${submission.member_quote.length}/500 characters`
            }

            // Set checkboxes
            document.getElementById('allowNameDisplay').checked = submission.allow_name_display
            document.getElementById('allowCreatorTypeDisplay').checked = submission.allow_creator_type_display  
            document.getElementById('allowCommentsDisplay').checked = submission.allow_comments_display
            document.getElementById('includeInGenesisGroup').checked = submission.include_in_genesis_group

            // Update UI
            updateSelectedTypes()
            updatePrivacyControls()

            // Delete the old submission and switch to form view
            deleteOfflineSubmissionSilent(submissionId)
            showFormStep()
            
            showSuccess('Submission loaded for editing. Make your changes and resubmit.')
        }

        function deleteOfflineSubmission(submissionId) {
            const submissions = getLocalSubmissions()
            const submission = submissions.find(sub => sub.id === submissionId)
            
            if (!submission) {
                showError('Submission not found')
                return
            }

            if (!confirm(`Delete offline submission for "${submission.name}" (${submission.email})? This cannot be undone.`)) {
                return
            }

            deleteOfflineSubmissionSilent(submissionId)
            populateOfflineSubmissions()
            updateViewToggle()
            showSuccess('Offline submission deleted')
        }

        function deleteOfflineSubmissionSilent(submissionId) {
            const submissions = getLocalSubmissions()
            const updatedSubmissions = submissions.filter(sub => sub.id !== submissionId)
            localStorage.setItem('dcSignups', JSON.stringify(updatedSubmissions))
        }

        // Global function for onclick handler
        function handleEditDetails() {
            console.log('handleEditDetails called')
            if (currentSubmission) {
                console.log('Restoring form data:', currentSubmission)
                try {
                    restoreFormData(currentSubmission)
                    console.log('restoreFormData completed successfully')
                } catch (error) {
                    console.error('‚ùå ERROR in restoreFormData:', error)
                    console.error('Error stack:', error.stack)
                    console.log('currentSubmission data:', currentSubmission)
                }
            }
            console.log('Calling showFormStep')
            try {
                showFormStep()
                console.log('showFormStep completed successfully')
            } catch (error) {
                console.error('‚ùå ERROR in showFormStep:', error)
                console.error('Error stack:', error.stack)
            }
        }

        // Global function for Join the Community button
        window.handleJoinCommunity = async function() {
            console.log('[DEBUG] handleJoinCommunity called, currentSubmission:', currentSubmission)
            if (currentSubmission) {
                console.log('[DEBUG] Calling submitConfirmedData...')
                await submitConfirmedData(currentSubmission)
                console.log('[DEBUG] submitConfirmedData completed')
            } else {
                console.log('[DEBUG] currentSubmission is null, cannot proceed')
                showError('No submission data found. Please fill out the form again.')
            }
        }

        // Setup event listeners for buttons
        console.log('[SCRIPT PROGRESS] About to define setupButtonListeners function');
        function setupButtonListeners() {
            console.log('[DEBUG] Setting up button listeners')
            // Confirmation step buttons - add null checks since they're in hidden elements
            // Edit button event listener removed - using onclick handler instead

            const confirmSubmitBtn = document.getElementById('confirmSubmitBtn')
            console.log('[DEBUG] Looking for confirmSubmitBtn:', confirmSubmitBtn)
            if (confirmSubmitBtn) {
                console.log('[DEBUG] Adding click listener to confirmSubmitBtn')
                confirmSubmitBtn.addEventListener('click', handleJoinCommunity)
            } else {
                console.log('[DEBUG] confirmSubmitBtn not found')
            }
        }

        // Event Listeners for new UI elements
        console.log('[DEBUG] Setting up event listeners, readyState:', document.readyState)
        if (document.readyState === 'loading') {
            console.log('[DEBUG] Document still loading, waiting for DOMContentLoaded')
            document.addEventListener('DOMContentLoaded', function() {
                console.log('[DEBUG] DOMContentLoaded fired, calling setupButtonListeners')
                migratePendingToOffline()
                setupButtonListeners()
            });
        } else {
            // DOM is already loaded, call setup immediately
            console.log('[DEBUG] DOM already loaded, calling setupButtonListeners immediately')
            migratePendingToOffline()
            setupButtonListeners()
        }

        document.addEventListener('DOMContentLoaded', function() {

            // View toggle buttons
            document.getElementById('formViewBtn').addEventListener('click', function() {
                showFormStep()
                document.getElementById('formViewBtn').classList.add('active')
                document.getElementById('offlineViewBtn').classList.remove('active')
            })

            document.getElementById('offlineViewBtn').addEventListener('click', function() {
                showOfflineViewer()
                document.getElementById('offlineViewBtn').classList.add('active')
                document.getElementById('formViewBtn').classList.remove('active')
            })

            // Offline viewer buttons - add null checks
            const backToFormBtn = document.getElementById('backToFormBtn')
            if (backToFormBtn) {
                backToFormBtn.addEventListener('click', function() {
                    showFormStep()
                    document.getElementById('formViewBtn').classList.add('active')
                    document.getElementById('offlineViewBtn').classList.remove('active')
                })
            }

            const syncNowBtn = document.getElementById('syncNowBtn')
            if (syncNowBtn) {
                syncNowBtn.addEventListener('click', async function() {
                    await syncPendingFromLocal()
                    populateOfflineSubmissions()
                    updateViewToggle()
                })
            }

            // Initialize view toggle state
            updateViewToggle()
        })

        // Navigation Functions
        function goToHomepage() {
            window.open('https://distributedcreatives.org', '_blank')
        }

        // Handle form submission when submit button is outside the form
        function handleFormSubmit() {
            const form = document.getElementById('signupForm')
            
            // Create a synthetic submit event
            const submitEvent = new Event('submit', {
                bubbles: true,
                cancelable: true
            })
            
            // Dispatch the submit event to trigger the existing form handler
            form.dispatchEvent(submitEvent)
        }

        // Simple Creator Type Modal Functions
        function openCreatorTypeModal() {
            console.log('Opening creator type modal...')
            const modal = document.getElementById('creatorTypeModal')
            if (!modal) {
                console.error('Modal element not found!')
                return
            }
            modal.style.display = 'flex'
            console.log('Modal opened, loading creator types...')
            if (creatorTypes.length === 0) {
                // If data not yet loaded, fetch it first then populate
                loadCreatorTypes().then(() => loadCreatorTypesIntoModal())
            } else {
                loadCreatorTypesIntoModal()
            }
        }

        function closeCreatorTypeModal() {
            document.getElementById('creatorTypeModal').style.display = 'none'
        }

        function loadCreatorTypesIntoModal() {
            console.log('üîß LOADING CREATOR TYPES INTO MODAL - START')
            const container = document.getElementById('creatorTypeCategories')

            if (!container) {
                console.error('‚ùå Container element not found!')
                return
            }

            console.log('‚úÖ Container found:', container)

            // EMERGENCY FIX: Hard-coded fallback ‚Äì only if no data is loaded
            if (!creatorTypes || creatorTypes.length === 0) {
                creatorTypes = [
                    {
                        id: "traditional-arts",
                        label: "Traditional Arts",
                        description: "Classic artistic mediums and forms",
                        children: [
                            { id: "visual-arts", label: "Visual Arts", description: "Painting, drawing, sculpture" },
                            { id: "music", label: "Music", description: "Composition, performance, production" },
                            { id: "writing", label: "Writing", description: "Fiction, non-fiction, poetry" },
                            { id: "photography", label: "Photography", description: "Digital and film photography" },
                            { id: "performance-acting", label: "Performance/Acting", description: "Theater, film, live performance" }
                        ]
                    },
                    {
                        id: "technical-creation",
                        label: "Technical Creation",
                        description: "Technology-focused creative work",
                        children: [
                            { id: "software-development", label: "Software Development", description: "Applications, systems, tools" },
                            { id: "game-development", label: "Game Development", description: "Video games, interactive media" },
                            { id: "web-development", label: "Web Development", description: "Websites, web applications" },
                            { id: "engineering", label: "Engineering", description: "Hardware, systems, innovation" },
                            { id: "data-science", label: "Data Science", description: "Analytics, visualization, AI/ML" }
                        ]
                    },
                    {
                        id: "content-creation",
                        label: "Content Creation",
                        description: "Digital content and media production",
                        children: [
                            { id: "video", label: "Video", description: "Film, streaming, video production" },
                            { id: "podcasting", label: "Podcasting", description: "Audio content, broadcasting" },
                            { id: "blogging", label: "Blogging", description: "Written online content" },
                            { id: "social-media", label: "Social Media", description: "Platform-specific content creation" }
                        ]
                    },
                    {
                        id: "design-fields",
                        label: "Design Fields",
                        description: "Visual and functional design work",
                        children: [
                            { id: "ux-ui-design", label: "UX/UI Design", description: "User experience, interface design" },
                            { id: "graphic-design", label: "Graphic Design", description: "Visual communication, branding" },
                            { id: "industrial-design", label: "Industrial Design", description: "Product design, manufacturing" }
                        ]
                    },
                    {
                        id: "other",
                        label: "Other",
                        description: "Creative work not listed above",
                        children: []
                    }
                ]
            } // end fallback guard
            console.log('‚úÖ Creator types loaded:', creatorTypes.length, 'categories')

            // EMERGENCY FIX: Simple, guaranteed-to-work HTML generation
            console.log('üîß Generating HTML for', creatorTypes.length, 'categories')

            let html = ''

            for (let i = 0; i < creatorTypes.length; i++) {
                const category = creatorTypes[i]
                const categorySelected = selectedCreatorTypes.includes(category.id)

                console.log(`Processing category: ${category.label}`)

                html += '<div class="creator-category">'
                html += `<div class="category-header ${categorySelected ? 'selected' : ''}" onclick="toggleCreatorType('${category.id}')">`
                html += '<div>'
                html += `<div class="category-title">${category.label}</div>`
                html += `<div class="category-description">${category.description}</div>`
                html += '</div>'
                html += `<div class="category-check ${categorySelected ? 'selected' : ''}">`
                html += categorySelected ? '‚úì' : ''
                html += '</div>'
                html += '</div>'

                if (category.id === 'other') {
                    html += '<div class="subcategories">'
                    html += `<input type="text" id="otherCreatorTypeInput" placeholder="e.g., Pottery, Stand-up Comedy, Fashion Design..." value="${otherValue || ''}" onkeyup="handleOtherInput(this.value)" onclick="handleOtherInputClick(event)" style="width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; background: white;">`
                    html += '</div>'
                } else if (category.children && category.children.length > 0) {
                    html += '<div class="subcategories">'
                    for (let j = 0; j < category.children.length; j++) {
                        const child = category.children[j]
                        const childSelected = selectedCreatorTypes.includes(child.id)
                        html += `<div class="subcategory-card ${childSelected ? 'selected' : ''}" onclick="event.stopPropagation(); toggleCreatorType('${child.id}');">`
                        html += `<div class="subcategory-title">${child.label}</div>`
                        html += `<div class="subcategory-description">${child.description}</div>`
                        html += '</div>'
                    }
                    html += '</div>'
                }

                html += '</div>'
            }

            console.log('‚úÖ HTML generated, length:', html.length)
            container.innerHTML = html
            console.log('‚úÖ Container updated successfully')
        }

        function toggleCreatorType(typeId) {
            const isCurrentlySelected = selectedCreatorTypes.includes(typeId)
            
            if (typeId === 'other') {
                // Special handling for "other" category
                if (isCurrentlySelected) {
                    // Deselect "other" - keep the text but don't include it in selection
                    selectedCreatorTypes = selectedCreatorTypes.filter(id => id !== 'other')
                    updateOtherCheckboxState(false)
                } else {
                    // Select "other" - include it in selection
                    selectedCreatorTypes.push('other')
                    updateOtherCheckboxState(true)
                    // Focus the input field when manually selecting
                    const otherInput = document.getElementById('otherCreatorTypeInput')
                    if (otherInput) {
                        otherInput.focus()
                    }
                }
                return // Don't refresh the entire modal for "other"
            }
            
            if (isCurrentlySelected) {
                // Remove the type
                selectedCreatorTypes = selectedCreatorTypes.filter(id => id !== typeId)
            } else {
                // Add the type
                selectedCreatorTypes.push(typeId)
                
                // Check if this is a parent category
                const parentCategory = creatorTypes.find(cat => cat.id === typeId)
                if (parentCategory && parentCategory.children) {
                    // If selecting a parent, remove any selected children to avoid duplication
                    const childIds = parentCategory.children.map(child => child.id)
                    selectedCreatorTypes = selectedCreatorTypes.filter(id => !childIds.includes(id))
                } else {
                    // If selecting a child, remove the parent category if it was selected
                    const parentOfChild = creatorTypes.find(cat => 
                        cat.children && cat.children.some(child => child.id === typeId)
                    )
                    if (parentOfChild && selectedCreatorTypes.includes(parentOfChild.id)) {
                        selectedCreatorTypes = selectedCreatorTypes.filter(id => id !== parentOfChild.id)
                    }
                }
            }
            
            loadCreatorTypesIntoModal() // Refresh to show selection
        }

        function saveCreatorTypes() {
            const modalOtherInput = document.getElementById('otherCreatorTypeInput')
            if (modalOtherInput) {
                const otherType = modalOtherInput.value.trim()
                if (otherType) {
                    otherValue = otherType
                    if (!selectedCreatorTypes.includes('other')) {
                        selectedCreatorTypes.push('other')
                    }
                } else if (selectedCreatorTypes.includes('other')) {
                    // If other is selected but no text, remove it
                    selectedCreatorTypes = selectedCreatorTypes.filter(id => id !== 'other')
                    otherValue = ""
                }
            }
            
            updateSelectedTypesDisplay()
            closeCreatorTypeModal()
        }

        function updateSelectedTypesDisplay() {
            console.log('[TRACE] updateSelectedTypesDisplay called')
            const display = document.getElementById('creatorTypeDisplay')
            const count = document.getElementById('selectionCount')
            const container = document.getElementById('selectedTypes')
            
            console.log('[TRACE] Elements found:', {
                display: display ? 'YES' : 'NO',
                count: count ? 'YES' : 'NO',
                container: container ? 'YES' : 'NO'
            })
            
            const totalCount = selectedCreatorTypes.length + (otherValue ? 1 : 0)
            
            // Add null check for count
            if (count) {
                count.textContent = `${totalCount} selected`
            }
            
            // Add null check for display
            if (display) {
                if (totalCount > 0) {
                    display.textContent = 'Creator types selected'
                } else {
                    display.textContent = 'Click to select your creator types'
                }
            }
            
            // Add null check for container
            if (container) {
                // Show selected types as tags
                container.innerHTML = ''
                selectedCreatorTypes.forEach(typeId => {
                    const type = findCreatorTypeById(typeId)
                    if (type) {
                        const tag = document.createElement('div')
                        tag.className = 'selected-type-tag'
                        tag.innerHTML = `${type.label} <button type="button" class="remove-type" onclick="removeCreatorType('${typeId}')">√ó</button>`
                        container.appendChild(tag)
                    }
                })
                
                if (otherValue) {
                    const tag = document.createElement('div')
                    tag.className = 'selected-type-tag'
                    tag.innerHTML = `Other: ${otherValue} <button type="button" class="remove-type" onclick="removeOtherType()">√ó</button>`
                    container.appendChild(tag)
                }
            }
        }

        function findCreatorTypeById(id) {
            for (const category of creatorTypes) {
                if (category.id === id) return category
                if (category.children) {
                    for (const child of category.children) {
                        if (child.id === id) return child
                    }
                }
            }
            return null
        }

        function removeCreatorType(typeId) {
            selectedCreatorTypes = selectedCreatorTypes.filter(id => id !== typeId)
            updateSelectedTypesDisplay()
        }

        function removeOtherType() {
            otherValue = ""
            const otherInput = document.getElementById('otherCreatorType')
            const modalOtherInput = document.getElementById('otherCreatorTypeInput')
            if (otherInput) otherInput.value = ""
            if (modalOtherInput) modalOtherInput.value = ""
            
            // Remove "other" from selected types
            selectedCreatorTypes = selectedCreatorTypes.filter(id => id !== 'other')
            updateSelectedTypesDisplay()
        }

        function handleOtherInput(value) {
            const trimmedValue = value.trim()
            otherValue = trimmedValue
            
            if (trimmedValue) {
                // Auto-select "other" category when text is entered
                if (!selectedCreatorTypes.includes('other')) {
                    selectedCreatorTypes.push('other')
                    // Only update the checkbox visual state, don't reload entire modal
                    updateOtherCheckboxState(true)
                }
            } else {
                // Remove "other" selection when text is cleared
                if (selectedCreatorTypes.includes('other')) {
                    selectedCreatorTypes = selectedCreatorTypes.filter(id => id !== 'other')
                    // Only update the checkbox visual state, don't reload entire modal
                    updateOtherCheckboxState(false)
                }
            }
        }

        function updateOtherCheckboxState(selected) {
            // Find the Other category header and update its visual state
            const otherHeaders = document.querySelectorAll('.category-header')
            otherHeaders.forEach(header => {
                const titleElement = header.querySelector('.category-title')
                if (titleElement && titleElement.textContent === 'Other') {
                    const checkElement = header.querySelector('.category-check')
                    if (selected) {
                        header.classList.add('selected')
                        checkElement.classList.add('selected')
                        checkElement.textContent = '‚úì'
                    } else {
                        header.classList.remove('selected')
                        checkElement.classList.remove('selected')
                        checkElement.textContent = ''
                    }
                }
            })
            
            // Update the input field visual state
            const otherInput = document.getElementById('otherCreatorTypeInput')
            if (otherInput) {
                if (selected) {
                    // Enabled state - normal styling
                    otherInput.style.color = '#374151'
                    otherInput.style.backgroundColor = 'white'
                    otherInput.style.borderColor = '#e5e7eb'
                    otherInput.style.opacity = '1'
                } else {
                    // Disabled state - grayed out
                    otherInput.style.color = '#9ca3af'
                    otherInput.style.backgroundColor = '#f9fafb'
                    otherInput.style.borderColor = '#d1d5db'
                    otherInput.style.opacity = '0.6'
                }
            }
        }

        function handleOtherInputClick(event) {
            event.stopPropagation()
            
            // Auto-select "other" when clicking in the input field
            if (!selectedCreatorTypes.includes('other')) {
                selectedCreatorTypes.push('other')
                updateOtherCheckboxState(true)
            }
        }
        
        // DEVELOPMENT AUTO-RELOAD - REMOVE BEFORE DEPLOYMENT
        if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
            let lastModified = null;
            setInterval(async () => {
                try {
                    const response = await fetch(location.href, { method: 'HEAD' });
                    const modified = response.headers.get('last-modified');
                    if (lastModified && lastModified !== modified) {
                        console.log('Page changed, reloading...');
                        location.reload();
                    }
                    lastModified = modified;
                } catch (e) {
                    // Ignore errors
                }
            }, 2000); // Check every 2 seconds
            console.log('Auto-reload enabled (dev mode)');
        }
        
        // Check for verification parameter and redirect to verification page
        const verifyParams = new URLSearchParams(window.location.search);
        const verifyToken = verifyParams.get('verify');
        if (verifyToken) {
            console.log('Verification token detected, redirecting to verify.html');
            window.location.href = `/verify.html?token=${verifyToken}`;
        }
        
        console.log('[SCRIPT END] DC Signup System script has finished loading');
    </script>
</body>
</html>